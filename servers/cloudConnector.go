package servers

import (
    "errors"
    "fmt"
    "time"
    "sync"
    "bytes"
    "runtime"
    "strconv"

    "github.com/nnset/iot-cloud-connector/connections"

    "github.com/sirupsen/logrus"
    "github.com/google/uuid"
)

/*
CloudConnector Helps you controling the status of incoming connections to
your server and also when to start and shut it down.
*/
type CloudConnector struct {
    id                     string // Autogenerated uuid for this instance
    startTime              int64  // When was this instance started in unix time
    totalConnections       uint64 // How many connections are currently opened against this instance
    totalMessagesProcessed uint64 // How many messages (incoming + outgoing) have been processed for this instance
    server                 ServerInterface // Custom implementation of a server that sets how 
                                           // IoT devices are connected, check ServerInterface
    activeConnections      map[string]*connections.DeviceConnection  // Map that controls the established connections
    shutdownChannel        *chan bool  // This channel will report when CloudConnector and its server has to be shutdown
    dataMutex              *sync.Mutex  // Mutex used for modifying this instance's data
    log                    *logrus.Logger  // Log
    certFile               string  // In case the server uses TLS, this is the path to the certFile
    keyFile                string  // In case the server uses TLS, this is the path to the keyFile
}

/*
CloudConnectorSettings Use this struct to initialize your CloudConnector
instances. All fields are required.
*/
type CloudConnectorSettings struct {
    Log                    *logrus.Logger
    ShutdownChannel        *chan bool
    Server                 ServerInterface
    CertFile               string
    KeyFile                string
}

/*
Init sets de necessary initial values to the CloudConnector instance
*/
func (cloudConnector *CloudConnector) Init(settings CloudConnectorSettings) {
    if cloudConnector.id == "" {
        cloudConnector.id = uuid.New().String()
        cloudConnector.startTime = time.Now().Unix()
        cloudConnector.dataMutex = &sync.Mutex{}
        cloudConnector.activeConnections = make(map[string]*connections.DeviceConnection)

        cloudConnector.shutdownChannel = settings.ShutdownChannel
        cloudConnector.server = settings.Server
        cloudConnector.log = settings.Log
        cloudConnector.certFile = settings.CertFile
        cloudConnector.keyFile = settings.KeyFile
    }
}

/*
Start begins to listen to requests, starting the serverInterface instance.
*/
func (cloudConnector *CloudConnector) Start() error {
    cloudConnector.log.Infof("Cloud Connector #%s starts.", cloudConnector.id)

    go cloudConnector.startServer()

    <-*cloudConnector.shutdownChannel

    cloudConnector.log.Info("Cloud Connector received shutdown signal, proceding to shutdown server")
    
    serverShutdownIsComplete := make(chan bool, 1)

    var err = cloudConnector.shutdownServer(&serverShutdownIsComplete)

    // TODO Timeout does not work
    select {
        case res := <-serverShutdownIsComplete:
            cloudConnector.log.Debug("Cloud Connector server successfully shutdown ", res)
        case <-time.After(2 * time.Second):
            cloudConnector.log.Error("Cloud Connector server shutdown time out.")
    }

    uptime, _ := cloudConnector.Uptime()

    cloudConnector.log.Info("Cloud Connector stopped.")
    cloudConnector.log.Info("  Total messages processed: ", cloudConnector.totalMessagesProcessed)
    cloudConnector.log.Infof("  Uptime: %d seconds", uptime)

    return err
}

func (cloudConnector *CloudConnector) startServer() {
    cloudConnector.log.Infof("Starting server %s", cloudConnector.server.Name())

    cloudConnector.server.Start(cloudConnector)
}

func (cloudConnector *CloudConnector) shutdownServer(serverShutdownIsComplete *chan bool) error {
    cloudConnector.log.Infof("Shutting server %s", cloudConnector.server.Name())

    return cloudConnector.server.Shutdown(serverShutdownIsComplete)
}

/*
AddConnection Use this method when a ServerInterface instance established a connection
with a device so CloudConnector may handle connection's stats
*/
func (cloudConnector *CloudConnector) AddConnection(connection *connections.DeviceConnection) (string, error) {
    
    _, alreadyConnected := cloudConnector.activeConnections[connection.ID()]

    if alreadyConnected {
        return "", fmt.Errorf(fmt.Sprintf("Connection rejected. Connection #%s with device #%s was already established.", connection.ID(), connection.DeviceID()))
    }

    cloudConnector.dataMutex.Lock()
        cloudConnector.activeConnections[connection.ID()] = connection
        cloudConnector.totalConnections++
    cloudConnector.dataMutex.Unlock()

    cloudConnector.log.Debug("New connection added")
    cloudConnector.log.Debugf("  activeConnections[%s]", connection.ID())
    cloudConnector.log.Debugf("  Monitored connections: %d", cloudConnector.totalConnections)
    cloudConnector.log.Debugf("  System memory: %d MB", cloudConnector.systemMemory())
    cloudConnector.log.Debugf("  Total allocated memory: %d MB", cloudConnector.totalAllocatedMemory())
    cloudConnector.log.Debugf("  Total Go routines: %d", cloudConnector.totalGoRoutinesSpawned())

    return connection.DeviceID(), nil
}

/*
CloseAllConnections Tries to close all active connections sending them the reason of the closure
*/
func (cloudConnector *CloudConnector) CloseAllConnections(reason string) {
    for _, connection := range cloudConnector.activeConnections {
        remoteAddress := connection.RemoteAddress()
        userAgent := connection.UserAgent()
        deviceID := connection.DeviceID()
        connectionID := connection.ID()

        err := cloudConnector.CloseConnection(connectionID, connections.StatusNormalClosure, reason)

        if err != nil {
            cloudConnector.log.Debugf("Unable to close connection #%s with device #%s from %s (%s) : %s", connectionID, deviceID, remoteAddress, userAgent, err)
        }
    }
}

/*
CloseConnection Closes a single connection.
Remember this is a potentially destructive action so do not rely that #connectionID is 
stored after calling this method.
*/
func (cloudConnector *CloudConnector) CloseConnection(connectionID string, statusCode connections.ConnectionStatusCode, reason string) error {
    
    if cloudConnector.activeConnections[connectionID] == nil {
        return errors.New("Connection not found")
    }

    connection := cloudConnector.activeConnections[connectionID]

    cloudConnector.log.Debugf("Closing connection #%s with device #%s from %s : %s", connection.ID(), connection.DeviceID(), connection.RemoteAddress(), reason)
    cloudConnector.log.Debugf("Total messages received: %d", connection.IncomingMessages())
    cloudConnector.log.Debugf("Total messages sent: %d", connection.OutgoingMessages())

    cloudConnector.dataMutex.Lock()
        err := connection.Close(statusCode, reason)
        delete(cloudConnector.activeConnections, connectionID)
        cloudConnector.totalConnections--
    cloudConnector.dataMutex.Unlock()

    return err
}

/*
MessageReceived A new message was received from a given connection
*/
func (cloudConnector *CloudConnector) MessageReceived(connectionID string) {
    cloudConnector.dataMutex.Lock()
        cloudConnector.activeConnections[connectionID].MessageReceived()
        cloudConnector.totalMessagesProcessed++
    cloudConnector.dataMutex.Unlock()
}

/*
MessageSent A new message was send to a given connection
*/
func (cloudConnector *CloudConnector) MessageSent(connectionID string) {
    cloudConnector.dataMutex.Lock()
        cloudConnector.activeConnections[connectionID].MessageSent()
    cloudConnector.dataMutex.Unlock()
}

/*
Uptime how many seconds the server has been up
*/
func (cloudConnector *CloudConnector) Uptime() (int64, error) {
    if cloudConnector.startTime == 0 {
        return -1, errors.New("CloudConnector has not been initiated")
    }

    return time.Now().Unix() - cloudConnector.startTime, nil
}

func (cloudConnector *CloudConnector) goRoutineID() uint64 {
    b := make([]byte, 64)
    b = b[:runtime.Stack(b, false)]
    b = bytes.TrimPrefix(b, []byte("goroutine "))
    b = b[:bytes.IndexByte(b, ' ')]
    n, _ := strconv.ParseUint(string(b), 10, 64)

    return n
}

// total mega bytes of memory obtained from the OS.
func (cloudConnector *CloudConnector) systemMemory() uint {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)

    return uint(m.Sys / 1024 / 1024)
}

// Cumulative mega bytes allocated for heap objects.
func (cloudConnector *CloudConnector) totalAllocatedMemory() uint {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)

    return uint(m.TotalAlloc / 1024 / 1024)
}

func (cloudConnector *CloudConnector) totalGoRoutinesSpawned() int {
    return runtime.NumGoroutine()
}
