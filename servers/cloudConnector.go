package servers

import (
    "errors"
    "fmt"
    "time"
    "bytes"
    "runtime"
    "strconv"

    "github.com/nnset/iot-cloud-connector/connections"
    "github.com/nnset/iot-cloud-connector/storage"

    "github.com/sirupsen/logrus"
    "github.com/google/uuid"
)

/*
CloudConnector Helps you controling the status of incoming connections to
your server and also when to start and shut it down.
*/
type CloudConnector struct {
    id                     string // Autogenerated uuid for this instance
    startTime              int64  // When was this instance started in unix time
    totalConnections       uint64 // How many connections are currently opened against this instance
    totalMessagesProcessed uint64 // How many messages (incoming + outgoing) have been processed for this instance
    shutdownChannel        *chan bool  // This channel will report when CloudConnector and its server has to be shutdown
    log                    *logrus.Logger  // Log

    server                 ServerInterface // Custom implementation of a server that sets how 
    connections            storage.DeviceConnectionsStorageInterface  // Where connections information is stored
    serverIsOnline         bool 
}

/*
NewCloudConnector creates a new instance of CloudConnector
*/
func  NewCloudConnector(
    shutdownChannel *chan bool, 
    log *logrus.Logger, 
    certFile, keyFile string, 
    server ServerInterface, 
    connections storage.DeviceConnectionsStorageInterface) *CloudConnector {

    return &CloudConnector {
        id: uuid.New().String(),
        startTime: time.Now().Unix(),
        shutdownChannel: shutdownChannel,
        log: log,
        server: server,
        connections: connections,
        serverIsOnline: false,
    }
}

/*
Start begins to listen to requests, starting the serverInterface instance.
*/
func (cloudConnector *CloudConnector) Start() error {
    cloudConnector.log.Infof("Cloud Connector #%s starts.", cloudConnector.id)

    go cloudConnector.startServer()

    <-*cloudConnector.shutdownChannel

    cloudConnector.log.Info("Cloud Connector received shutdown signal, proceding to shutdown server")
    
    serverShutdownIsComplete := make(chan bool, 1)

    var err = cloudConnector.shutdownServer(&serverShutdownIsComplete)

    // TODO Timeout does not work
    select {
        case res := <-serverShutdownIsComplete:
            cloudConnector.log.Debug("Cloud Connector server successfully shutdown ", res)
        case <-time.After(2 * time.Second):
            cloudConnector.log.Error("Cloud Connector server shutdown time out.")
    }

    uptime, _ := cloudConnector.Uptime()

    cloudConnector.log.Info("Cloud Connector stopped.")
    cloudConnector.log.Info("  Total messages processed: ", cloudConnector.totalMessagesProcessed)
    cloudConnector.log.Infof("  Uptime: %d seconds", uptime)
    cloudConnector.log.Infof("  Server: %t", cloudConnector.serverIsOnline)

    return err
}

func (cloudConnector *CloudConnector) startServer() {
    cloudConnector.log.Infof("Starting server %s", cloudConnector.server.Name())

    cloudConnector.server.Start(cloudConnector)
    cloudConnector.serverIsOnline = true
}

func (cloudConnector *CloudConnector) shutdownServer(serverShutdownIsComplete *chan bool) error {
    cloudConnector.log.Infof("Shutting server %s", cloudConnector.server.Name())

    err := cloudConnector.server.Shutdown(serverShutdownIsComplete)

    cloudConnector.serverIsOnline = false
        
    return err
}

/*
ConnectionEstablished Use this method when a ServerInterface instance established a connection
with a device so CloudConnector may handle connection's stats
*/
func (cloudConnector *CloudConnector) ConnectionEstablished(connection *connections.DeviceConnection) error {
    _, err := cloudConnector.connections.Get(connection.ID())

    if err == nil {
		cloudConnector.log.Error(err)
        return fmt.Errorf(fmt.Sprintf("Connection rejected. Connection #%s with device #%s was already established.", connection.ID(), connection.DeviceID()))
    }

    cloudConnector.connections.Add(
        connection.ID(), 
        connection.DeviceID(), 
        connection.DeviceType(), 
        connection.UserAgent(), 
        connection.RemoteAddress(),
    )

    cloudConnector.log.Debugf("New connection added #%s", connection.ID())
    cloudConnector.log.Debugf("  Monitored connections: %d", cloudConnector.connections.TotalConnections())
    cloudConnector.log.Debugf("  System memory: %d MB", cloudConnector.systemMemory())
    cloudConnector.log.Debugf("  Total allocated memory: %d MB", cloudConnector.totalAllocatedMemory())
    cloudConnector.log.Debugf("  Total Go routines: %d", cloudConnector.totalGoRoutinesSpawned())

    return nil
}

/*
ConnectionClosed Called when a server closes a connection
*/
func (cloudConnector *CloudConnector) ConnectionClosed(
    connectionID string, 
    statusCode connections.ConnectionStatusCode, 
    reason string,
    ) error {
  
    stats, err := cloudConnector.connections.Get(connectionID)

    if(err != nil) {
        return err
    }
    
    cloudConnector.log.Debugf("Closing connection #%s with device #%s from %s : %s",connectionID, stats.DeviceID(), stats.RemoteAddress(), reason)
    cloudConnector.log.Debugf("Total messages received: %d", stats.ReceivedMessages())
    cloudConnector.log.Debugf("Total messages sent: %d", stats.SentMessages())

    return cloudConnector.connections.Delete(connectionID)
}

/*
MessageReceived A new message was received from a given connection
*/
func (cloudConnector *CloudConnector) MessageReceived(connectionID string) {
    cloudConnector.connections.MessageReceived(connectionID)
}

/*
MessageSent A new message was sent to a given connection
*/
func (cloudConnector *CloudConnector) MessageSent(connectionID string) {
    cloudConnector.connections.MessageSent(connectionID)
}

/*
Uptime how many seconds the server has been up
*/
func (cloudConnector *CloudConnector) Uptime() (int64, error) {
    if cloudConnector.startTime == 0 {
        return -1, errors.New("CloudConnector has not been initiated")
    }

    return time.Now().Unix() - cloudConnector.startTime, nil
}

func (cloudConnector *CloudConnector) goRoutineID() uint64 {
    b := make([]byte, 64)
    b = b[:runtime.Stack(b, false)]
    b = bytes.TrimPrefix(b, []byte("goroutine "))
    b = b[:bytes.IndexByte(b, ' ')]
    n, _ := strconv.ParseUint(string(b), 10, 64)

    return n
}

// total mega bytes of memory obtained from the OS.
func (cloudConnector *CloudConnector) systemMemory() uint {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)

    return uint(m.Sys / 1024 / 1024)
}

// Cumulative mega bytes allocated for heap objects.
func (cloudConnector *CloudConnector) totalAllocatedMemory() uint {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)

    return uint(m.TotalAlloc / 1024 / 1024)
}

func (cloudConnector *CloudConnector) totalGoRoutinesSpawned() int {
    return runtime.NumGoroutine()
}

/*
ID Current Id
*/
func (cloudConnector *CloudConnector) ID() string {
    return cloudConnector.id
}

/*
IsServerOnline Is the server that handles connections and messages online?
*/
func (cloudConnector *CloudConnector) IsServerOnline() bool {
    return cloudConnector.serverIsOnline
}

/*
TotalConnections How many connections are alive
*/
func (cloudConnector *CloudConnector) TotalConnections() int {
    return cloudConnector.connections.TotalConnections()
}

/*
ReceivedMessages How many messages has the server received from a given connection
*/
func (cloudConnector *CloudConnector) ReceivedMessages(connectionID string) uint64 {
    return cloudConnector.connections.ReceivedMessages(connectionID)
}

/*
SentMessages How many messages has the server sent to a given connection
*/
func (cloudConnector *CloudConnector) SentMessages(connectionID string) uint64 {
    return cloudConnector.connections.SentMessages(connectionID)
}
